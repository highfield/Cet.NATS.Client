
/********************************************************************************
 * The MIT License (MIT)
 * 
 * Copyright 2018+ Cet Electronics.
 * 
 * Based on the original work by Apcera Inc.
 * https://github.com/nats-io/csharp-nats
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*********************************************************************************/

using IllyriadGames.ByteArrayExtensions;
using System.Text;

namespace Cet.NATS.Client
{
    /// <summary>
    /// Represents an output message received from the NATS server,
    /// and consumed by the host app.
    /// This typically holds data sent by another endpoint.
    /// </summary>
    public sealed class MsgOut
    {
        /// <summary>
        /// Creates a <see cref="MsgOut"/>, but that's allowed only to the NATS client.
        /// </summary>
        /// <param name="subject">The target subject to deliver the message to.</param>
        /// <param name="replyTo">The target subject to deliver the response message to.</param>
        /// <param name="subId">The ID assigned to the subscription responsible to dispatch this message.</param>
        internal MsgOut(
            string subject,
            string replyTo,
            long subId
            )
        {
            this.Subject = subject;
            this.ReplyTo = replyTo;
            this.SubId = subId;
        }


        private byte[] _payloadInternal = Helpers.EmptyByteArray;


        /// <summary>
        /// The target subject to deliver the message to,
        /// as indicated in the original <see cref="MsgIn"/> message.
        /// </summary>
        public readonly string Subject;


        /// <summary>
        /// The target subject to deliver the response message to.
        /// </summary>
        /// <remarks>
        /// This can be the explicit value of a <see cref="MsgIn"/> message,
        /// but also a special target generated by an INBOX subscription.
        /// </remarks>
        public readonly string ReplyTo;


        /// <summary>
        /// A read-only copy of the subscription ID
        /// </summary>
        internal readonly long SubId;


        /// <summary>
        /// The number of bytes of the raw-payload (byte array)
        /// </summary>
        public int PayloadLength { get; internal set; }


        /// <summary>
        /// Gets the reference to the <see cref="ISubscription"/> responsible
        /// to dispatch this message.
        /// </summary>
        public ISubscription ArrivalSubcription { get; internal set; }


        /// <summary>
        /// Sets the payload of the message as a byte-array.
        /// </summary>
        /// <remarks>
        /// The access of this method is allowed only to the NATS client infrastructure.
        /// </remarks>
        /// <param name="buffer">The byte array with the data as payload</param>
        internal void SetPayload(byte[] buffer)
        {
            this._payloadInternal = new byte[this.PayloadLength];

            //since the local payload byte-array is exposed to the host,
            //here it makes a copy of the given data
            VectorizedCopyExtension.VectorizedCopy(
                buffer,
                0,
                this._payloadInternal,
                0,
                this.PayloadLength
                );
        }


        /// <summary>
        /// Gets the payload as byte-array
        /// </summary>
        /// <returns>The payload as byte array</returns>
        public byte[] GetPayloadAsByteArray()
        {
            return this._payloadInternal;
        }


        /// <summary>
        /// Copies the payload to a host-provided byte-array.
        /// </summary>
        /// <param name="buffer">The target byte-array, which should be large enough to hold the data.</param>
        /// <param name="offset">The starting position to copy the bytes from.</param>
        /// <returns>The number of bytes copied.</returns>
        public int GetPayloadAsByteArray(byte[] buffer, int offset)
        {
            int count = this._payloadInternal.Length;

            //since the local payload byte-array is exposed to the host,
            //here it makes a copy of the given data
            VectorizedCopyExtension.VectorizedCopy(
                this._payloadInternal,
                0,
                buffer,
                offset,
                count
                );

            return count;
        }


        /// <summary>
        /// Gets the payload as a string, encoded as UTF-8.
        /// </summary>
        /// <returns></returns>
        public string GetPayloadAsString()
        {
            return Encoding.UTF8.GetString(this._payloadInternal);
        }


        /// <summary>
        /// Copies the payload to a host-provided char-array.
        /// </summary>
        /// <param name="buffer">The target char-array, which should be large enough to hold the data.</param>
        /// <param name="offset">The starting position to copy the chars from.</param>
        /// <returns>The number of chars copied.</returns>
        public int GetPayloadAsString(char[] buffer, int offset)
        {
            return Encoding.UTF8.GetChars(
                this._payloadInternal, 
                0, 
                this._payloadInternal.Length, 
                buffer, 
                offset
                );
        }


        /// <summary>
        /// Just a commodity function to summarize the instance content.
        /// </summary>
        /// <returns>A debugging-context string</returns>
        public override string ToString()
        {
            return $"{nameof(MsgOut)}: sbj={this.Subject}; rpl={this.ReplyTo}; sid={this.SubId}; size={this.PayloadLength}";
        }

    }
}
